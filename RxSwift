RxSwift
RxCocoa
RxDataSources
RxFeedback


Область применения

В основе Rx лежат потоки событий, на которые отлично ложаться асихронные вычисления и логика основанная на событиях.


Область применения в МП

Обычное мобильное приложение - это графический интервейс между пользователем и бэк-эндом.

Асихронность в МП:
* API бэк-энда (потому что сеть)
* Пользовательский ввод (потому что основан на событиях)
* API ОС типа геолокации и прочего.
* все тяжелое операции, которыми мы не хотим грузить основной поток

В общем куда не сунься, а почти везде всё асинхронное.

Что нам предлагает iOS?

* NSThread
	+ полный контроль над происходязщим
	- все надо сделать самому
	- больший простор для ошибок

* Grand Central Dispatch
 	+ моделирует очереди с независимыми задачами
 	+ поддерживает последовательное и параллельное выполнение задач
 	- не подерживает зависимости между операциями
 	- нет встроенного механизма для обмена данными между задачами
 	- нет встроенного механизма обработки ошибок
 	- одно вычисление - один результат
 	- код начинает быстро пухнать, как только нужно что-то сложнее, чем подождать одну операцию, или все операции в группе

* NSOperationQueue
	+ моделирует очереди зависимых задач
	+ поддерживает последовательное и параллельное выполнение задач
	+ задачи могут зависить друг от друга
	- менеджмент жизненного цикла операции, который заключается в том, что нужно взводить флажки, а так же проверять их состояние
	- весьма многословной и не слишком наглядный API для настройки зависимостей
	- нет встроенного механизма для передачи данных между задачами
	- одно вычисление - один результат
	- встроенный механизм обработки ошибок весьма ограничен: завалить зависимые операции, или нет

* NSNotificationCenter
	+ по сути это шина
	+ хорошо в простых случаях типа fire and forget
	- плохо во все остальных
	- тяжело разбирать поток управления, потому что тяжело сказать, где что началось и где оно заканчивается
	- никакой строгой типизации

* делегаты
* функции обратного вызова

* KVO
	- крайне неуклюжий API, который провоцирует на ошибки (под Swift лучше)
	- тяжело разбирать поток управления, потому что тяжело сказать, где что началось и где оно заканчивается

Что нам предлагает Rx?

* Observable<T>
	+ моделирует поток событий с весьма простых жизненным циклом: [next*] (completed | error)
	+ отлично подходят для инкапсуляции асинхроного вычисления
	+ может возвращатся серию значений, а не только одно
	+ встроенный механизм передачи данных между вычислениями
	+ встроенный механизм обработки ошибок
	+ лаконичный декларативный API для описания зависимостей между вычислениями
	+ встроенный мезанизм отмены вычислений
	+ планировщики, которые позволяют раскидать вычисления по очередям
	+ различные стратегии по разделению результатов вычислений
	+ вычисление может быть чистым, а может и включать побычные эффекты
	+ строгая типизация для результатов вычислений (но не для ошибок)
	- тяжело въехать
	- неопределенности, связанные с жизненным циклом вычисления:
		* вычисление может завершиться с ошибкой, а может и нет
		* вычисление может вернуть некоторое значение, а может ничего не возвращать и сводиться к побочным эффектам
		* какая конкретная стратегия разделения вычислений применена в конкретном случае?
	- в общем случае нельзя понять сопровождается ли вычисление побочными эффектами, или нет
	- в общем случае нельзя понять на каком потоке происходит вычисления
